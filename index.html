<script src="./js globals/live.js"></script>
<script src="./js globals/libloader.user.js"></script>
<script src="./js globals/allfuncs.user.js"></script>
<script src="./js globals/better logs.user.js"></script>

<!-- <script src="./eruda.js"></script> -->

<script src="./cryptojs.js"></script>
<script src="./protectedtextapi.js"></script>
<script src="./jsonblobapi.js"></script>

<link rel="stylesheet" href="style.css" />
<span class="installlinks">
  <a
    href="https://chromewebstore.google.com/detail/violentmonkey/jinjaccalgkegednnccohejagnlnfdag"
    target="_blank"
    >violentmonkey</a
  >
  <a href="./globalrequest.user.js" target="_self">globalrequest</a>
</span>
<button id="download">download</button>
<input
  type="text"
  autocomplete="off"
  id="username"
  placeholder="enter your name here"
/>
<input type="checkbox" name="notification" id="notification" />
<label for="notification">notify on data change</label>
<br>
<span>left click for yes, right click for no</span>
<div id="sticky">
  <input
    autocomplete="off"
    type="text"
    id="taskname"
    placeholder="name of new task"
  />
  <button id="addtask">add task</button>
</div>
<table id="table">
  <thead>
    <tr style="position: sticky">
      <th>name</th>
      <th>PLAYER COUNT</th>
      <th>likes</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>
<script>
  // add my ideas
  // add way to filter by users liked/disliked/likable
  // add way to filter by valid player counts
  // add reload button/polling reload
  const a = loadlib("allfuncs")

  a.listen(window, "scroll", function () {
    const stickyElement = a.qs("#sticky")
    if (window.scrollY >= 50) {
      stickyElement.classList.add("scrolled")
    } else {
      stickyElement.classList.remove("scrolled")
    }
  })
  a.qs("#notification").checked = localStorage.sendnoti == "true"
  a.listen(a.qs("#notification"), "change", (e) => {
    localStorage.sendnoti = String(a.qs("#notification").checked)
  })
  a.listen(a.qs("#download"), "click", async (e) => {
    a.download(await API.load(), "summer test backup - " + Date.now())
  })
  a.qs("#username").value = localStorage.name ?? ""
  a.listen(a.qs("#username"), "change", () => {
    localStorage.name = a.qs("#username").value
  })
  a.listen(a.qs("#addtask"), "click", () => {
    addNewEvent(a.qs("#taskname").value)
  })
  window.globalrequest = (data) => {
    if (typeof data == "string") data = { url: data }
    var { url, method, headers } = data
    headers ??= []
    method ??= "GET"
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest()

      xhr.open(method, url, true)

      // Set request headers
      for (const key in headers) {
        xhr.setRequestHeader(key, headers[key])
      }

      // Set up the callback for when the request completes
      xhr.onload = function () {
        if (xhr.status >= 200 && xhr.status < 300) {
          // Resolve the promise with the response data
          resolve({ text: xhr.responseText })
        } else {
          // Reject the promise with the status text
          error(xhr.statusText, xhr.responseText)
          reject(new Error(xhr.responseText))
        }
      }

      // Handle network errors
      xhr.onerror = function () {
        reject(new Error("Network Error"))
      }

      // Send the request with the data
      xhr.send(data.body ? data.body : undefined)
    })
  }
  if (window.globalrequest) {
    start()
  } else {
    var timeout = setTimeout(() => {
      if (!window.globalrequest) {
        alert(
          "click the link for violentmonkey, install the extension then click globalrequest and install that too"
        )
      }
    }, 4000)
    var interval = setInterval(() => {
      if (window.globalrequest) {
        clearTimeout(timeout)
        clearInterval(interval)
        start()
      }
    }, 100)
  }
  function sendnoti() {
    if (!("Notification" in window)) {
      // Check if the browser supports notifications
      alert("This browser does not support desktop notification")
    } else if (Notification.permission === "granted") {
      // Check whether notification permissions have already been granted;
      // if so, create a notification
      const notification = new Notification("data updated!")
      // â€¦
    } else if (Notification.permission !== "denied") {
      // We need to ask the user for permission
      Notification.requestPermission().then((permission) => {
        // If the user accepts, let's create a notification
        if (permission === "granted") {
          const notification = new Notification("data updated!")
        }
      })
    }
  }
  async function start() {
    setInterval(async () => {
      var data = await API.load()
      if (data !== window.lastdata) {
        loadAllData(data)
        window.lastdata = data
        if (localStorage.sendnoti == "true") {
          sendnoti()
        }
      }
    }, 5 * 60 * 1000)
    a.qs(".installlinks").classList.add("hide")
    const API = (window.API = await new jsonblobapi(
      "1352826891148648448"
    ))
    // const API = (window.API = await new protectedtextapi(
    //   "summerplans",
    //   "summertest"
    // ))
    var data = JSON.parse(await API.load())
    window.lastdata = data
    await a.bodyload()
    loadAllData(data)
  }
  function loaddata(idx, data) {
    const table = a.qs("#table>tbody")
    var { name, likes, validPlayerCounts, desc } = data
    validPlayerCounts ??= []
    desc ??= ""
    if (table.children.length <= idx)
      table.appendChild(
        a.newelem(
          "tr",
          {
            class: "row",
          },
          [
            a.newelem(
              "td",
              {
                display: "flex",
                flexDirection: "column",
                gap: "5px",
              },
              [
                a.newelem("input", {
                  autocomplete: "off",
                  fieldSizing: "content",
                  maxWidth: "190px",
                  minWidth: "40px",
                  class: "taskname",
                  onchange(e) {
                    renameEvent(this.oldname, this.value)
                  },
                }),
                a.newelem("button", {
                  innerHTML: "delete",
                  id: "delete",
                  onclick(e) {
                    if (confirm(this.thingname))
                      removeEvent(this.thingname)
                  },
                }),
              ]
            ),
            a.newelem("td", {}, [
              a.newelem("div", {
                textContent: 1,
                class: "playerCount",
                onclick: validPlayerCount,
                oncontextmenu: invalidPlayerCount,
              }),
              a.newelem("div", {
                textContent: 2,
                class: "playerCount",
                onclick: validPlayerCount,
                oncontextmenu: invalidPlayerCount,
              }),
              a.newelem("div", {
                class: "playerCount",
                textContent: 3,
                onclick: validPlayerCount,
                oncontextmenu: invalidPlayerCount,
              }),
              a.newelem("div", {
                textContent: 4,
                class: "playerCount",
                onclick: validPlayerCount,
                oncontextmenu: invalidPlayerCount,
              }),
              a.newelem("div", {
                textContent: 5,
                class: "playerCount",
                onclick: validPlayerCount,
                oncontextmenu: invalidPlayerCount,
              }),
            ]),
            a.newelem(
              "td",
              {
                // justifyContent: "space-between",
                gap: "2px",
              },
              likes.map((e) =>
                a.newelem("div", {
                  padding: "2px",
                  onclick(e) {
                    e.preventDefault()
                    if (this.username == localStorage.name) {
                      like(this.thingname, 1)
                    }
                  },
                  oncontextmenu(e) {
                    e.preventDefault()
                    if (this.username == localStorage.name) {
                      like(this.thingname, -1)
                    }
                  },
                })
              )
            ),
            a.newelem("td", {}, [
              a.newelem("textarea", {
                autocomplete: "off",
                class: "desc",
                onchange: updateDesc,
              }),
            ]),
          ]
        )
      )
    // else {
    var child = [...table.children][idx]
    a.qs("tr>td>button#delete", child).thingname =
      a.qs("tr>td>input", child).oldname =
      a.qs("tr>td>input", child).value =
        name
    var validPlayerCountsElems = a.qsa(
      "tr>td:nth-of-type(2)>div.playerCount",
      child
    )
    for (let child of validPlayerCountsElems) {
      child.thingname = name
      child.classList.remove(
        !validPlayerCounts.includes(child.textContent)
          ? "valid"
          : "invalid"
      )
      child.classList.add(
        validPlayerCounts.includes(child.textContent)
          ? "valid"
          : "invalid"
      )
    }
    var likesParentElem = a.qs("tr>td:nth-of-type(3)", child)
    var ii = 0
    for (let ii = 0; ii < likes.length; ii++) {
      let child = [...likesParentElem.children][ii]
      var thislike = likes.sort((a, b) =>
        a.name.localeCompare(b.name)
      )[ii]
      child.username = child.textContent = thislike.name
      child.thingname = name
      child.className =
        thislike.liked == 1
          ? "liked"
          : thislike.liked == -1
          ? "disliked"
          : "likable"
    }
    var descElem = a.qs("tr>td:nth-of-type(4)>textarea.desc", child)
    descElem.value = desc
    descElem.thingname = name
    // }
  }

  async function like(thing, liked) {
    var data = JSON.parse(await API.load())
    try {
      data
        .find((e) => e.name == thing)
        .likes.find((e) => e.name == localStorage.name).liked = liked
      await API.save(JSON.stringify(data))
    } catch (e) {}
    loadAllData(data)
  }

  function loadAllData(data) {
    data = data.toReversed()
    for (var i = 0; i < data.length; i++) {
      loaddata(i, data[i])
    }
    var children = a.qsa("table>tbody>*")
    while (children.length > data.length) {
      children.pop().remove()
    }
  }

  async function updateDesc(event) {
    event.preventDefault()
    try {
      var data = JSON.parse(await API.load())
      var thing = data.find((e) => e.name == event.target.thingname)
      thing.desc = event.target.value
      await API.save(JSON.stringify(data))
      loadAllData(data)
    } catch (e) {}
    loadAllData(data)
  }

  async function validPlayerCount(event) {
    event.preventDefault()
    var data = JSON.parse(await API.load())
    try {
      var thing = data.find((e) => e.name == event.target.thingname)
      thing.validPlayerCounts ??= []
      if (
        !thing.validPlayerCounts.includes(event.target.textContent)
      ) {
        thing.validPlayerCounts.push(event.target.textContent)
        loadAllData(data)
        await API.save(JSON.stringify(data))
        loadAllData(JSON.parse(await API.load()))
      }
    } catch (e) {
      loadAllData(data)
    }
  }
  async function invalidPlayerCount(event) {
    event.preventDefault()
    var data = JSON.parse(await API.load())
    try {
      var thing = data.find((e) => e.name == event.target.thingname)
      thing.validPlayerCounts ??= []
      if (
        thing.validPlayerCounts.includes(event.target.textContent)
      ) {
        thing.validPlayerCounts.splice(
          thing.validPlayerCounts.indexOf(event.target.textContent),
          1
        )
        loadAllData(data)
        await API.save(JSON.stringify(data))
        loadAllData(JSON.parse(await API.load()))
      } else {
        loadAllData(data)
      }
    } catch (e) {
      loadAllData(data)
    }
  }
  async function addNewEvent(name) {
    var data = JSON.parse(await API.load())
    data.push({
      name,
      likes: [
        { name: "jaden", liked: 0 },
        { name: "river", liked: 0 },
        { name: "mom", liked: 0 },
        { name: "pheonix", liked: 0 },
        { name: "mike", liked: 0 },
      ],
    })
    loadAllData(data)
    await API.save(JSON.stringify(data))
    loadAllData(JSON.parse(await API.load()))
  }

  async function removeEvent(name) {
    var data = JSON.parse(await API.load())
    try {
      data.splice(data.indexOf(data.find((e) => e.name == name)), 1)
      await API.save(JSON.stringify(data))
      loadAllData(data)
      loadAllData(JSON.parse(await API.load()))
    } catch (e) {
      loadAllData(data)
    }
  }
  async function renameEvent(oldname, newname) {
    var data = JSON.parse(await API.load())
    try {
      data.find((e) => e.name == oldname).name = newname
      loadAllData(data)
      await API.save(JSON.stringify(data))
      loadAllData(JSON.parse(await API.load()))
    } catch (e) {
      loadAllData(data)
    }
  }
</script>
